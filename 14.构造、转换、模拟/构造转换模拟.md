# 构造转换模拟

- [构造转换模拟](#构造转换模拟)
  - [例题](#例题)
    - [CF1916D Mathematical Problem](#cf1916d-mathematical-problem)
      - [CF1916D题意](#cf1916d题意)
      - [CF1916D题解](#cf1916d题解)
      - [CF1916D参考代码](#cf1916d参考代码)
    - [CF1912E Evaluate It and Back Again](#cf1912e-evaluate-it-and-back-again)
      - [CF1912E题意](#cf1912e题意)
      - [CF1912E题解](#cf1912e题解)
      - [CF1912E参考代码](#cf1912e参考代码)

无概念，直接例题

## 例题

### [CF1916D Mathematical Problem](https://www.luogu.com.cn/problem/CF1916D)

#### CF1916D题意

给定奇数 $n$，求出 $n$ 个正整数满足：

- 都是完全平方数。
- 长度为 $n$ 且没有前导 $0$。
- 组成这 $n$ 个数的数字（ $[0,9]$ 内数字）组成的可重集相同。

输出任意一种方案。

#### CF1916D题解

打表观察发现：

```txt
13: 169
14: 196 n=3
31: 961

103: 10609 130: 16900
140: 19600 n=5
301: 90601 310: 96100

1003: 1006009 1030: 1060900 1300: 1690000
1400: 196000 n=7
3001: 9006001 3010: 9060100 3100: 9610000
```

在输入为 $n$ 的情况下，只需要每次把 $n-3$ 个 $0$ 分别分配到 $14$ 的后面及 $13,31$ 的后面和中间即可。

#### CF1916D参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
void work(char s[])
{
    printf("%s",s);
    for (int i = 1; i <= n - 3; ++i)
        printf("0");
    printf("\n");
}
int main()
{
#ifndef ONLINE_JUDGE
    freopen("2.in", "r", stdin);
#endif
    int t;
    scanf("%d", &t);
    while (t--)
    {
        scanf("%d", &n);
        if (n == 1)
        {
            puts("1");
            continue;
        }
        work("169");
        work("196");
        work("961");
        for (int i = 1; i < n / 2; ++i) //
        {
            printf("1");
            for (int j = 1; j <= i; ++j)
                printf("0");
            printf("6");
            for (int j = 1; j <= i; ++j)
                printf("0");
            printf("9");
            for (int j = 3 + 2 * i; j < n; ++j)
                printf("0");
            printf("\n");

            printf("9");
            for (int j = 1; j <= i; ++j)
                printf("0");
            printf("6");
            for (int j = 1; j <= i; ++j)
                printf("0");
            printf("1");
            for (int j = 3 + 2 * i; j < n; ++j)
                printf("0");
            printf("\n");
        }
    }
    return 0;
}
```

### [CF1912E Evaluate It and Back Again](https://www.luogu.com.cn/problem/CF1912E)

#### CF1912E题意

给定两个数，要求你写出一个只包含数字, $+, \times, -$ 的式子，正着看是第一个数，反着看是第二个数。

#### CF1912E题解

观察发现只有**正一位数**和 $+, \times$ 的**单项式**倒过来读还是一样的，由 $-0$ 结尾的单项式倒过来读和原式结果相反。

发现可以将一个要求倒着读后数值不变的数表示为 $9$ 进制的形式，这样多项式中每一项都是倒着读后不变的。

- 对于两个奇偶性相同的数，可以求两个数的平均数，将 $p, q$ 分别表示为 $p = \overline{pq} + \frac{p - q}{2}, q = \overline{pq} - \frac{p - q}{2}$
- 对于两个奇偶性不同的数，也可以求平均数，但是为了让 $p, q$ 奇偶性统一，需要给 $p, q$ 分别减去一个正着读是奇数，反着读是偶数的数，如 $12$，然后即可按照第一种形式做

然后就是注意特判两个相同的数和 `0 0` 的情况，别忘记开long long就结束了

#### CF1912E参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;
string ans;
string to_9(long long n) //转换为正反均相同的多项式
{
    bool flag = n >= 0;
    if (!flag)
        n = -n;
    ans = "";
    long long cnt = 0;
    long long yu[20] = {};
    while (n >= 10ll)
        yu[cnt++] = n % 9ll, n /= 9ll;
    yu[cnt] = n;
    if (!flag)
        ans += "0-";
    for (long long i = 0; i <= cnt; ++i)
    {
        if (yu[cnt - i] != 0)
        {
            for (long long j = 0; j < cnt - i; ++j)
                ans += "9*";
            ans += yu[cnt - i] + '0';
            if (flag)
                ans += "+0+";
            else
                ans += "-0-";
        }
    }
    while (ans[ans.size() - 1] == '+' || ans[ans.size() - 1] == '-')
        ans.pop_back(); // 去掉多于符号
    return ans;
}
string to_9_0(long long n) // 转换为正反读相反的多项式
{
    bool flag = n >= 0;
    if (!flag)
        n = -n;
    ans = "";
    long long cnt = 0;
    long long yu[20] = {};
    while (n >= 10)
    {
        yu[cnt++] = n % 9ll;
        n /= 9ll;
    }
    yu[cnt] = n;
    if (!flag)
        ans += "0-";
    for (long long i = 0; i <= cnt; ++i)
    {
        if (yu[cnt - i] != 0)
        {
            for (long long j = 0; j < cnt - i; ++j)
                ans += "9*";
            ans += yu[cnt - i] + '0';
            if (flag)
                ans += "-0+";
            else
                ans += "+0-";
        }
    }
    while (ans[ans.size() - 1] == '+' || ans[ans.size() - 1] == '-')
        ans.pop_back(); // 去掉多于符号
    return ans;
}
int main()
{
    long long p = 0, q = 0;
    scanf("%lld%lld", &p, &q);
    if (abs(p) % 2 == abs(q) % 2) // 同奇偶
    {
        long long _pq = p + q >> 1, p_q = p - _pq;
        if (p == 0 && q == 0) // 特判
        {
            puts("0");
            return 0;
        }
        cout << to_9(_pq) << ((_pq != 0 && p_q != 0) ? "+" : "") << to_9_0(p_q) << endl;
    }
    else // 异奇偶
    {
        long long _pq = (p - 21 + q - 12) >> 1, p_q = p - 21 - _pq; // 转换为同奇偶
        cout << to_9(_pq) << ((_pq != 0 && p_q != 0) ? "+" : "") << to_9_0(p_q) << ((p_q != 0 || _pq != 0) ? "+" : "") << "21" << endl;
    }
    return 0;
}

```

---
