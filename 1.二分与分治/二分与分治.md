# 二分与分治

- [二分与分治](#二分与分治)
  - [应用](#应用)
    - [二分答案](#二分答案)
    - [实数二分](#实数二分)
      - [寻找函数零点](#寻找函数零点)
      - [01分数规划](#01分数规划)
      - [最小比值生成树](#最小比值生成树)
    - [三分](#三分)
      - [求连续函数的极值点](#求连续函数的极值点)
  - [模板代码](#模板代码)
    - [二分答案](#二分答案-1)
    - [实数二分](#实数二分-1)

## 应用

### 二分答案

[代码](#二分答案)

### 实数二分

[代码](#实数二分)

#### 寻找函数零点

![单个](image.png)

单个：一次实数二分

![多个](image-1.png)

多个：分割成段，多次二分

#### 01分数规划

给定等长数列 $a_i$, $b_i$, 求同样等长的数列 $w_i (w_i \in{0,1})$ , 最大化（或最小化）$\frac{\sum_i w_ia_i}{\sum_i w_ib_i}$ 。

考虑二分 $\frac{\sum_i w_ia_i}{\sum_i w_ib_i}$ 的最大值，在每一次二分中，相当于是验证 $\max{\frac{\sum_i w_i·a_i}{\sum_i w_i·b_i} \ge mid}$ 是否成立。

经过化简，每次二分的 $check$ 则变为了判断是否存在一组 $w_i$ 使 $\sum_iw_i(a_i-mid\times{b_i})\ge0$

#### 最小比值生成树

在一张无向连通图中，边具有 $a_i,b_i$ 两个权值，最小比值生成树是使 $\frac{\sum{a[i]}}{\sum{b[i]}}$ 最小的生成树

考虑用 $w_i (w_i\in{0,1})$ 表示每条边是否选入树中，则该问题可转换为[01分数规划问题](#01分数规划)

所以，我们令树上每一条边的边权为 $c_i(c_i=a_i-mid\times{b_i})$ ，然后便可转换为朴素最小生成树问题

### 三分

#### 求连续函数的极值点

要求：单峰或单谷函数

## 模板代码

### 二分答案

```cpp
// 二分答案
int l = 0, r = n;
while (l <= r)
{
    int mid = l + r >> 1;
    if (check(mid))
        l = mid + 1;
    else
        r = mid - 1;
}
return l;
```

### 实数二分

```cpp
// 实数二分
double l = 0, r = n;
while (r - l > eps)
{
    double mid = (l + r) / 2;
    if (check(mid))
        l = mid;
    else
        r = mid;
}
```
