# 数学

- [数学](#数学)
  - [费马小定理，逆元，同余](#费马小定理逆元同余)
    - [同余](#同余)
      - [同余的表示](#同余的表示)
      - [同余的性质](#同余的性质)
    - [逆元](#逆元)
      - [求解逆元](#求解逆元)
      - [快速求解逆元](#快速求解逆元)
    - [例题](#例题)
      - [B3717 组合数问题](#b3717-组合数问题)
        - [B3717题意](#b3717题意)
        - [B3717题解](#b3717题解)
      - [LOJ161乘法逆元2](#loj161乘法逆元2)
  - [欧几里得算法、中国剩余定理](#欧几里得算法中国剩余定理)
    - [欧几里得算法](#欧几里得算法)
    - [扩展欧几里得](#扩展欧几里得)
      - [扩展欧几里得参考代码](#扩展欧几里得参考代码)

## 费马小定理，逆元，同余

### 同余

#### 同余的表示

若 $a \bmod m = b \bmod m$，则我们称 $a, b$ 同余，记作 $a \equiv b \pmod m$。

注意：c++中，一个负数 mod 另一个数结果还是负数。如 $-11 \% 3 = -2$。而在数学中， $-11 \% 3 = 1$

若 $a \equiv b \bmod m$，则 $m | (a - b), a - b = km (k \in \Z)$，其中 $\Z$ 表示整数集合

#### 同余的性质

- 自反性： $a \equiv a \pmod m$
- 对称性：若 $a \equiv b \pmod m$，则 $b \equiv a \pmod m$
- 传递性：若 $a \equiv b \pmod m, b \equiv c \pmod m$，则 $a \equiv c \pmod m$

类似等式，在同余式的两边同时进行相同的线性运算也不影响结果。

如：

$$
a \equiv b \pmod m, c \equiv d \pmod m\\
\Downarrow \\
a \pm c \equiv b \pm d \pmod m \\
a \times c \equiv b \times d \pmod m
$$

### 逆元

当 $ab \equiv 1 \pmod m$，则称在模 $m$ 意义下 $a, b$ 互为逆元。

可以将 $b$ 记作 $a^{-1}$

#### 求解逆元

求解模 $m$ 意义下的逆元，相当于求解 $ax \equiv 1 \pmod m$ 中的 $x$。

可以发现，当 $a$ 和 $m$ 互质时，原方程才有解，**即 $a$ 和 $m$ 互质时， $a$ 存在逆元**。

由于使用扩展欧几里得算法求解过于复杂，下面将会介绍一种更为简单地方法。

若 $\gcd(a, p) = 1$，则 $a^{p - 1} \equiv 1 \pmod p, p \in \mathbb P$，其中 $\mathbb P$ 表示质数集合。

根据这一定理，我们可以发现 $a \times a^{p - 2} \equiv 1 \pmod p$

所以，在模 $p$ 的意义下， $a$ 与 $a^{p - 2}$ 互为逆元。

故可以用快速幂来求解逆元，时间复杂度为 $O(\log m)$

需要注意的是，这种方法只适用于模数为质数的情况。非质数的情况需要用扩展欧几里得算法求解。

#### 快速求解逆元

费马小定理单次求解逆元的复杂度为 $O(\log m)$，若要求解 $[1, m)$ 中所有数的逆元，总的时间复杂度为 $O(m \log m)$

为了应对这种情况，还有一种 $O(m)$ 的递推方法，用于快速求解逆元。

首先，不难发现，对于任意的模数， $1$ 与本身都互为逆元。

接下来考虑递推。

假设已知 $[1, x)$ 中所有数的逆元，要求 $x$ 的逆元。

首先将 $m$ 表示为 $kx + t$

其中 $k=\lfloor \frac{m}{x} \rfloor, t = m \bmod x$

所以 $kx + t \equiv 0 \pmod m$

在两边同乘 $x^{-1} \times t^{-1}$ 后，可得 $kt^{-1} + x^{-1} \equiv 0 \pmod m$

移项后得到 $x^{-1} \equiv -kt^{-1} \pmod m$，即得到递推式 $x^{-1} \equiv -\lfloor \frac{m}{x} \rfloor (m \bmod x)^{-1} \pmod m$

而因为 $1 \le (m \bmod x) \le x$，则一定可以从已有的值推出 $x^{-1}$

### 例题

#### [B3717 组合数问题](https://www.luogu.com.cn/problem/B3717)

##### B3717题意

给定多组 $n, m$，求 $C^n_m \bmod 998244353$

##### B3717题解

首先展开：

$C^n_m=\frac{n!}{m! \times (n - m)!}$

因此为了快速求解，就需要为呼出所有数的阶乘及其逆元。

如果对于每个数的阶乘单独求逆元，肯定无法通过此题。

所以我们记 $fact_x = \prod^x_{i = 1} i$ 表示 $x$ 的阶乘， $inv_x$ 表示 $x$ 的逆元。

首先预处理 $inv_n = fact_n^{p - 2}$ （快速幂）

然后可以递推求解： $inv_x = \frac{1}{x!} = (x + 1) \times inv_{x + 1}$

预处理复杂度为 $O(n)$，单次查询复杂度为 $O(1)$

#### [LOJ161乘法逆元2](https://loj.ac/p/161)

## 欧几里得算法、中国剩余定理

### 欧几里得算法

对于任意的正整数 $a \ge b$，若 $a \equiv 0 \pmod b$， $\gcd(a, b) = b$，否则令 $a = kb + a \bmod b$

设 $S_i$ 表示 $i$ 的因数集合，注意到 $S_x \cap S_b = S_a \cap S_b$，所以可以得到如下推论:

$$\gcd(a, b) = \gcd(b, a \bmod b)$$

因此通过

```cpp
int gcd(int a, int b){ return !b ? a : gcd(b, a % b);}
```

即可求出 gcd

### 扩展欧几里得

对于任意正整数 $a, b$，考虑一元二次方程 $ax + by = c$ 的整数解

对于任意整数 $x$，存在 $y = \frac{c - ax}{b}$ 为唯一解，所以只需要考虑这个式子是否为整数，即是否存在 $x$ 使得

$$ax \equiv c \pmod b$$

考虑 $c = \gcd(a, b)$ 时如何找到一组解。

显然当 $a = 0$ 或 $b = 0$ 时可以直接找到解。（不是废话，等会递归时要用）

假设已知 $(a \bmod b)x + by = \gcd(a, b)$ 的一组解 $x', y'$ 则：

$$
(a \bmod b)x' + by' = \gcd(a, b)\\
ax + by = \gcd(a, b)
$$

取 $x = x'$，两式相减得到：

$$
(a - a \bmod b)x + b(y - y') = 0
$$

注意到 $a - a \bmod b = b \times \lfloor \frac{a}{b} \rfloor$，因此该方程有整数解：

$$
y = y' - \frac{(a - a \bmod b)x}{b} = y' -  \lfloor \frac{a}{b} \rfloor x
$$

然后递归求解即可（**看代码**）

易证 $|x| \le |b|, |y| \le |a|$

这样就求到了一组特解 $x_0, y_0$，考虑求令一组解 $x, y$

$
\left\{
    \begin{aligned}
        ax_0 + by_0 &= c \\
        ax + by &= c \\
    \end{aligned}
\right.
\rArr
a(x - x_0) + b(y - y_0) = 0
\rArr
\left\{
    \begin{aligned}
        a(x - x_0) &= k\ lcm(a, b) = k \frac{ab}{\gcd(a, b)} \\
        -b(y - y_0) &= k\ lcm(a, b) = k \frac{ab}{\gcd(a, b)} \\
    \end{aligned}
\right.
\rArr
\left\{
    \begin{aligned}
        x &= k \frac{b}{\gcd(a, b)} + x_0 \\
        y &= k \frac{a}{\gcd(a, b)} + y_0 \\
    \end{aligned}
\right.
$

这样就找到了令一组解

#### 扩展欧几里得参考代码

```cpp
int exgcd(int a, int b, int &x, int &y)
{
    if (b == 0)
    {
        x = 1, y = 0;
        return a;
    }
    int g = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return g;
}
```
