# 数学

- [数学](#数学)
  - [费马小定理，逆元，同余](#费马小定理逆元同余)
    - [同余](#同余)
      - [同余的表示](#同余的表示)
      - [同余的性质](#同余的性质)
    - [逆元](#逆元)
      - [求解逆元](#求解逆元)
      - [快速求解逆元](#快速求解逆元)
    - [费马小定理，逆元，同余例题](#费马小定理逆元同余例题)
      - [B3717 组合数问题](#b3717-组合数问题)
        - [B3717题意](#b3717题意)
        - [B3717题解](#b3717题解)
      - [LOJ161乘法逆元2](#loj161乘法逆元2)
  - [欧几里得算法、中国剩余定理](#欧几里得算法中国剩余定理)
    - [欧几里得算法](#欧几里得算法)
    - [扩展欧几里得](#扩展欧几里得)
      - [扩展欧几里得参考代码](#扩展欧几里得参考代码)
    - [欧几里得算法例题](#欧几里得算法例题)
      - [P1516 青蛙的约会](#p1516-青蛙的约会)
        - [P1516题意](#p1516题意)
        - [P1516题解](#p1516题解)
      - [CF1010C Border](#cf1010c-border)
        - [CF1010C题意](#cf1010c题意)
        - [CF1010C题解](#cf1010c题解)
        - [CF1010C代码](#cf1010c代码)
      - [CF1427E Xum](#cf1427e-xum)
        - [CF1427E题意](#cf1427e题意)
        - [CF1427E题解](#cf1427e题解)

## 费马小定理，逆元，同余

### 同余

#### 同余的表示

若 $a \bmod m = b \bmod m$，则我们称 $a, b$ 同余，记作 $a \equiv b \pmod m$。

注意：c++中，一个负数 mod 另一个数结果还是负数。如 $-11 \% 3 = -2$。而在数学中， $-11 \% 3 = 1$

若 $a \equiv b \bmod m$，则 $m | (a - b), a - b = km (k \in \Z)$，其中 $\Z$ 表示整数集合

#### 同余的性质

- 自反性： $a \equiv a \pmod m$
- 对称性：若 $a \equiv b \pmod m$，则 $b \equiv a \pmod m$
- 传递性：若 $a \equiv b \pmod m, b \equiv c \pmod m$，则 $a \equiv c \pmod m$

类似等式，在同余式的两边同时进行相同的线性运算也不影响结果。

如：

$$
a \equiv b \pmod m, c \equiv d \pmod m\\
\Downarrow \\
a \pm c \equiv b \pm d \pmod m \\
a \times c \equiv b \times d \pmod m
$$

### 逆元

当 $ab \equiv 1 \pmod m$，则称在模 $m$ 意义下 $a, b$ 互为逆元。

可以将 $b$ 记作 $a^{-1}$

#### 求解逆元

求解模 $m$ 意义下的逆元，相当于求解 $ax \equiv 1 \pmod m$ 中的 $x$。

可以发现，当 $a$ 和 $m$ 互质时，原方程才有解，**即 $a$ 和 $m$ 互质时， $a$ 存在逆元**。

由于使用扩展欧几里得算法求解过于复杂，下面将会介绍一种更为简单地方法。

若 $\gcd(a, p) = 1$，则 $a^{p - 1} \equiv 1 \pmod p, p \in \mathbb P$，其中 $\mathbb P$ 表示质数集合。

根据这一定理，我们可以发现 $a \times a^{p - 2} \equiv 1 \pmod p$

所以，在模 $p$ 的意义下， $a$ 与 $a^{p - 2}$ 互为逆元。

故可以用快速幂来求解逆元，时间复杂度为 $O(\log m)$

需要注意的是，这种方法只适用于模数为质数的情况。非质数的情况需要用扩展欧几里得算法求解。

#### 快速求解逆元

费马小定理单次求解逆元的复杂度为 $O(\log m)$，若要求解 $[1, m)$ 中所有数的逆元，总的时间复杂度为 $O(m \log m)$

为了应对这种情况，还有一种 $O(m)$ 的递推方法，用于快速求解逆元。

首先，不难发现，对于任意的模数， $1$ 与本身都互为逆元。

接下来考虑递推。

假设已知 $[1, x)$ 中所有数的逆元，要求 $x$ 的逆元。

首先将 $m$ 表示为 $kx + t$

其中 $k=\lfloor \frac{m}{x} \rfloor, t = m \bmod x$

所以 $kx + t \equiv 0 \pmod m$

在两边同乘 $x^{-1} \times t^{-1}$ 后，可得 $kt^{-1} + x^{-1} \equiv 0 \pmod m$

移项后得到 $x^{-1} \equiv -kt^{-1} \pmod m$，即得到递推式 $x^{-1} \equiv -\lfloor \frac{m}{x} \rfloor (m \bmod x)^{-1} \pmod m$

而因为 $1 \le (m \bmod x) \le x$，则一定可以从已有的值推出 $x^{-1}$

### 费马小定理，逆元，同余例题

#### [B3717 组合数问题](https://www.luogu.com.cn/problem/B3717)

##### B3717题意

给定多组 $n, m$，求 $C^n_m \bmod 998244353$

##### B3717题解

首先展开：

$C^n_m=\frac{n!}{m! \times (n - m)!}$

因此为了快速求解，就需要为呼出所有数的阶乘及其逆元。

如果对于每个数的阶乘单独求逆元，肯定无法通过此题。

所以我们记 $fact_x = \prod^x_{i = 1} i$ 表示 $x$ 的阶乘， $inv_x$ 表示 $x$ 的逆元。

首先预处理 $inv_n = fact_n^{p - 2}$ （快速幂）

然后可以递推求解： $inv_x = \frac{1}{x!} = (x + 1) \times inv_{x + 1}$

预处理复杂度为 $O(n)$，单次查询复杂度为 $O(1)$

#### [LOJ161乘法逆元2](https://loj.ac/p/161)

## 欧几里得算法、中国剩余定理

### 欧几里得算法

对于任意的正整数 $a \ge b$，若 $a \equiv 0 \pmod b$， $\gcd(a, b) = b$，否则令 $a = kb + a \bmod b$

设 $S_i$ 表示 $i$ 的因数集合，注意到 $S_x \cap S_b = S_a \cap S_b$，所以可以得到如下推论:

$$\gcd(a, b) = \gcd(b, a \bmod b)$$

因此通过

```cpp
int gcd(int a, int b){ return !b ? a : gcd(b, a % b);}
```

即可求出 gcd

### 扩展欧几里得

对于任意正整数 $a, b$，考虑一元二次方程 $ax + by = c$ 的整数解

对于任意整数 $x$，存在 $y = \frac{c - ax}{b}$ 为唯一解，所以只需要考虑这个式子是否为整数，即是否存在 $x$ 使得

$$ax \equiv c \pmod b$$

考虑 $c = \gcd(a, b)$ 时如何找到一组解。

显然当 $a = 0$ 或 $b = 0$ 时可以直接找到解。（不是废话，等会递归时要用）

假设已知 $(a \bmod b)x + by = \gcd(a, b)$ 的一组解 $x', y'$ 则：

$$
(a \bmod b)x' + by' = \gcd(a, b)\\
ax + by = \gcd(a, b)
$$

取 $x = x'$，两式相减得到：

$$
(a - a \bmod b)x + b(y - y') = 0
$$

注意到 $a - a \bmod b = b \times \lfloor \frac{a}{b} \rfloor$，因此该方程有整数解：

$$
y = y' - \frac{(a - a \bmod b)x}{b} = y' -  \lfloor \frac{a}{b} \rfloor x
$$

然后递归求解即可（**看代码**）

易证 $|x| \le |b|, |y| \le |a|$

这样就求到了一组特解 $x_0, y_0$，考虑求令一组解 $x, y$

$
\left\{
    \begin{aligned}
        ax_0 + by_0 &= c \\
        ax + by &= c \\
    \end{aligned}
\right.
\rArr
a(x - x_0) + b(y - y_0) = 0
\rArr
\left\{
    \begin{aligned}
        a(x - x_0) &= k\ lcm(a, b) = k \frac{ab}{\gcd(a, b)} \\
        -b(y - y_0) &= k\ lcm(a, b) = k \frac{ab}{\gcd(a, b)} \\
    \end{aligned}
\right.
\rArr
\left\{
    \begin{aligned}
        x &= k \frac{b}{\gcd(a, b)} + x_0 \\
        y &= -k \frac{a}{\gcd(a, b)} + y_0 \\
    \end{aligned}
\right.
$

这样就找到了令一组解

#### 扩展欧几里得参考代码

```cpp
int exgcd(int a, int b, int &x, int &y)
{
    if (b == 0)
    {
        x = 1, y = 0;
        return a;
    }
    int g = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return g;
}
```

### 欧几里得算法例题

#### [P1516 青蛙的约会](https://www.luogu.com.cn/problem/P1516)

##### P1516题意

两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。

我们把这两只青蛙分别叫做青蛙 A 和青蛙 B，并且规定纬度线上东经 $0$ 度处为原点，由东往西为正方向，单位长度 $1$ 米，这样我们就得到了一条首尾相接的数轴。设青蛙 A 的出发点坐标是 $x$，青蛙 B 的出发点坐标是 $y$。青蛙 A 一次能跳 $m$ 米，青蛙 B 一次能跳 $n$ 米，两只青蛙跳一次所花费的时间相同。纬度线总长 $L$ 米。现在要你求出它们跳了几次以后才会碰面。

$1 \le x \ne y \le 2 \times 10^{9}$，$1 \le m, n \le 2 \times 10^{9}$, $1 \le L \le INT\_MAX$。

##### P1516题解

设 $k$ 时刻相遇。

$$
(m - n)k \equiv (y - x) \pmod l
$$

若 $y - x$ 不是 $\gcd(m - n, l)$ 的倍数，则无解。

否则，令

$$
g \larr \gcd(y - x, l), b = \frac{y - x}{g}, a = \frac{m - n}{g}, l' = \frac{l}{g}
$$

要求的值即为 $ak \equiv b \pmod {l'}$ 的 $k$

由于 $\gcd(l', a) = 1$， $a$ 在 $\bmod {l'}$ 意义下逆元存在，即 $k \equiv ba^{-1} \pmod {l'}$

所以只需要找出满足

$$
aa^{-1} - kl' = 1
$$

的 $a^{-1}, k$ 即可，且 $0 \le a^{-1} \lt l$

复杂度 $O(\log V)$， $V$ 为输入数据范围最大值

#### [CF1010C Border](https://www.luogu.com.cn/problem/CF1010C)

##### CF1010C题意

给定 $n$ 个数 $\{a_i\}_{i = 1}^{n}$，求这些数的线性组合模 $k$ 有多少种不同的值

##### CF1010C题解

根据裴蜀定理：

$$
\sum_{i = 1}^{n}c_i a_i = c
$$

有解当且仅当 $c$ 是 $\gcd(a_1, ..., a_n)$ 的倍数，也就是说原式的线性组合一定是 $\gcd(a_1, ..., a_n)$ 的倍数。

这是二维裴蜀定理（ $ax + by = c$ 有解，当且仅当 $c$ 是 $\gcd(a, b)$ 的倍数）的扩展

考虑将方程变形：

$$
\sum^{n}_{i = 1}c_i a_i \equiv c \pmod k \rArr \sum^{n}_{i = 1} c_i a_i - c_{n + 1} a_{n + 1} = c \\
(0 \le c \le k, a_{n + 1} \larr k) \\
$$

也就是说有解的 $c$ 一定是 $\gcd(a_1, ..., a_n, k)$ 的倍数。依次输出即可。

时间复杂度 $O((n + k) \log k)$

##### CF1010C代码

```cpp
// LUOGU_RID: 170388733
#include <bits/stdc++.h>
#define int long long
using namespace std;
int a[100005];
vector<int> q;
signed main()
{
    int n, k;
    int ans;
    scanf("%lld%lld", &n, &k);
    for (int i = 1; i <= n; ++i)
    {
        scanf("%lld", &a[i]);
        if (i == 1)
            ans = a[1];
        else
            ans = __gcd(ans, a[i]);
    }
    ans = __gcd(ans, k);
    int ns = 0;
    while (ans * ns < k)
    {
        q.push_back(ns * ans);
        ++ns;
    }
    printf("%d\n", q.size());
    for (int i : q)
        printf("%lld ", i);
    puts("");
    return 0;
}
```

#### [CF1427E Xum](https://www.luogu.com.cn/problem/CF1427E)

##### CF1427E题意

给定一个集合 $\{x\}$， $x$ 是奇数，你可以对这个集合进行如下操作：

- 选取集合里的两个数 $x, y$，插入 $x + y$
- 选取集合里的两个数 $x, y$，插入 $x\ \text{xor}\ y$

##### CF1427E题解
