# 动态规划

- [动态规划](#动态规划)
  - [背包，区间](#背包区间)
    - [背包](#背包)
      - [01背包](#01背包)
      - [完全背包](#完全背包)
      - [多重背包](#多重背包)
      - [混合背包](#混合背包)
      - [分组背包](#分组背包)
      - [有依赖的背包](#有依赖的背包)
      - [背包问题的第 $k$ 优解](#背包问题的第-k-优解)
  - [树形，换根](#树形换根)
  - [状压](#状压)

## 背包，区间

### 背包

#### 01背包

给定 $n$ 个物品，第 $i$ 个的体积为 $v_i$，价值为 $w_i$，每个物品至多选一次，求最大价值。

转移方程 $f(i, j) = max(f(i - 1, j), f(i - 1, j - v_i) + w_i)$

时间复杂度 $O(nm)$

#### 完全背包

给定 $n$ 个物品，第 $i$ 个的体积为 $v_i$，价值为 $w_i$，每个物品无限拿，求最大价值。

转移方程 $f(i, j) = max(f(i - 1, j), f(i, j - v_i) + w_i)$

时间复杂度 $O(nm)$

#### 多重背包

给定 $n$ 个物品，第 $i$ 个的体积为 $v_i$，价值为 $w_i$，每个物品有 $t_i$ 个，求最大价值。

考虑 $t_i$ 的二进制，若第 $k$ 位为 $1$，则新建一个体积为 $v_i 2^k$，价值为 $w_i 2^k$ 的物品，转换为[01背包](#01背包)。

时间复杂度 $O(nm \log m)$

#### 混合背包

就是将[01背包](#01背包)，[完全背包](#完全背包)，[多重背包](#多重背包)混合在一起。

因为 dp 数组并没有规定是哪种背包，所以共用一个数组， 分三类做即可。时间复杂度 $O(nm)$

#### 分组背包

有 $n$ 个物品，第 $i$ 个物品价值为 $w_i$ 体积为 $v_i$ 并且属于第 $t_i$ 组。

有一个容量为 $m$ 的背包，问在每组最多选一个且体积不超过 $W$ 的条件下的最大价值。

一组一组进行考虑。对于每一组，从大到小枚举 $j$ 表示这一组的体积，然后枚举每一个物品即可。

核心代码：

```cpp
for (int i = 1; i <= m; ++i)
{
    for (int j = W; j >= 0; --j)
    {
        for (auto x : items[i])
        {
            if (j >= v[x])
                f[j] = max(f[j], f[j - v[x]] + w[x]);
        }
    }
}
```

#### 有依赖的背包

金明有 $n$ 元钱， $m$ 个物品，第 $i$ 件物品的价格为 $v_i$，重要度为 $p_i$。有些物品是主件，可以直接购买；有些物品是附件，要先买下主件才能买附件。

求最大的 $v_i \times p_i$

$n \le 3.2 \times 10^4, m \le 60, 0 \le v_i \le 10^4, 1 \le p_i \le 5$。每个主件最多有两个附件。

对于每个主件 $A$ 以及附件 $B, C$，只有这几种选法： $\varnothing, \{A\}, \{A, B\}, \{A, C\}, \{A, B, C\}$

考虑将其转换为每组 $4$ 个物品的[分组背包](#分组背包)求解。

#### 背包问题的第 $k$ 优解

普通01背包只能求出最优解，在普通背包上稍作改动，增加一维用于记录当前状态前 $k$ 优解，即可求出背包问题的第 $k$ 优解。

具体的，考虑原本的转移： $f_{i, j} = max(f_{i - 1, j}, f_{i - 1, j - v_i} + w_i)$

所有不选 $i$ 的构成序列 $[f_{i - 1, j, 1}, ...,f_{i - 1, j, k}]$

所有选 $i$ 的构成序列 $[f_{i - 1, j - v_i, 1} + w_i, ...,f_{i - 1, j - v_i, k} + w_i]$

合并后即得到 $f_{i, j, k}$

时间复杂度 $O(nmk)$

---

## 树形，换根

---

## 状压

---
