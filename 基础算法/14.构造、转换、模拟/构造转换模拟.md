# 构造转换模拟

- [构造转换模拟](#构造转换模拟)
  - [例题](#例题)
    - [CF1916D Mathematical Problem](#cf1916d-mathematical-problem)
      - [CF1916D题意](#cf1916d题意)
      - [CF1916D题解](#cf1916d题解)
      - [CF1916D参考代码](#cf1916d参考代码)
    - [CF1912E Evaluate It and Back Again](#cf1912e-evaluate-it-and-back-again)
      - [CF1912E题意](#cf1912e题意)
      - [CF1912E题解](#cf1912e题解)
      - [CF1912E参考代码](#cf1912e参考代码)
    - [CF739A Alyona and mex](#cf739a-alyona-and-mex)
      - [CF739A题意](#cf739a题意)
      - [CF739A题解](#cf739a题解)
      - [CF739A代码](#cf739a代码)
    - [CF1495C Garden of the Sun](#cf1495c-garden-of-the-sun)
      - [CF1495C题意](#cf1495c题意)
      - [CF1495C题解](#cf1495c题解)
      - [CF1495C代码](#cf1495c代码)

无概念，直接例题

## 例题

### [CF1916D Mathematical Problem](https://www.luogu.com.cn/problem/CF1916D)

#### CF1916D题意

给定奇数 $n$，求出 $n$ 个正整数满足：

- 都是完全平方数。
- 长度为 $n$ 且没有前导 $0$。
- 组成这 $n$ 个数的数字（ $[0,9]$ 内数字）组成的可重集相同。

输出任意一种方案。

#### CF1916D题解

打表观察发现：

```txt
13: 169
14: 196 n=3
31: 961

103: 10609 130: 16900
140: 19600 n=5
301: 90601 310: 96100

1003: 1006009 1030: 1060900 1300: 1690000
1400: 196000 n=7
3001: 9006001 3010: 9060100 3100: 9610000
```

在输入为 $n$ 的情况下，只需要每次把 $n-3$ 个 $0$ 分别分配到 $14$ 的后面及 $13,31$ 的后面和中间即可。

#### CF1916D参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
void work(char s[])
{
    printf("%s",s);
    for (int i = 1; i <= n - 3; ++i)
        printf("0");
    printf("\n");
}
int main()
{
#ifndef ONLINE_JUDGE
    freopen("2.in", "r", stdin);
#endif
    int t;
    scanf("%d", &t);
    while (t--)
    {
        scanf("%d", &n);
        if (n == 1)
        {
            puts("1");
            continue;
        }
        work("169");
        work("196");
        work("961");
        for (int i = 1; i < n / 2; ++i) //
        {
            printf("1");
            for (int j = 1; j <= i; ++j)
                printf("0");
            printf("6");
            for (int j = 1; j <= i; ++j)
                printf("0");
            printf("9");
            for (int j = 3 + 2 * i; j < n; ++j)
                printf("0");
            printf("\n");

            printf("9");
            for (int j = 1; j <= i; ++j)
                printf("0");
            printf("6");
            for (int j = 1; j <= i; ++j)
                printf("0");
            printf("1");
            for (int j = 3 + 2 * i; j < n; ++j)
                printf("0");
            printf("\n");
        }
    }
    return 0;
}
```

### [CF1912E Evaluate It and Back Again](https://www.luogu.com.cn/problem/CF1912E)

#### CF1912E题意

给定两个数，要求你写出一个只包含数字, $+, \times, -$ 的式子，正着看是第一个数，反着看是第二个数。

#### CF1912E题解

观察发现只有**正一位数**和 $+, \times$ 的**单项式**倒过来读还是一样的，由 $-0$ 结尾的单项式倒过来读和原式结果相反。

发现可以将一个要求倒着读后数值不变的数表示为 $9$ 进制的形式，这样多项式中每一项都是倒着读后不变的。

- 对于两个奇偶性相同的数，可以求两个数的平均数，将 $p, q$ 分别表示为 $p = \overline{pq} + \frac{p - q}{2}, q = \overline{pq} - \frac{p - q}{2}$
- 对于两个奇偶性不同的数，也可以求平均数，但是为了让 $p, q$ 奇偶性统一，需要给 $p, q$ 分别减去一个正着读是奇数，反着读是偶数的数，如 $12$，然后即可按照第一种形式做

然后就是注意特判两个相同的数和 `0 0` 的情况，别忘记开long long就结束了

#### CF1912E参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;
string ans;
string to_9(long long n) //转换为正反均相同的多项式
{
    bool flag = n >= 0;
    if (!flag)
        n = -n;
    ans = "";
    long long cnt = 0;
    long long yu[20] = {};
    while (n >= 10ll)
        yu[cnt++] = n % 9ll, n /= 9ll;
    yu[cnt] = n;
    if (!flag)
        ans += "0-";
    for (long long i = 0; i <= cnt; ++i)
    {
        if (yu[cnt - i] != 0)
        {
            for (long long j = 0; j < cnt - i; ++j)
                ans += "9*";
            ans += yu[cnt - i] + '0';
            if (flag)
                ans += "+0+";
            else
                ans += "-0-";
        }
    }
    while (ans[ans.size() - 1] == '+' || ans[ans.size() - 1] == '-')
        ans.pop_back(); // 去掉多于符号
    return ans;
}
string to_9_0(long long n) // 转换为正反读相反的多项式
{
    bool flag = n >= 0;
    if (!flag)
        n = -n;
    ans = "";
    long long cnt = 0;
    long long yu[20] = {};
    while (n >= 10)
    {
        yu[cnt++] = n % 9ll;
        n /= 9ll;
    }
    yu[cnt] = n;
    if (!flag)
        ans += "0-";
    for (long long i = 0; i <= cnt; ++i)
    {
        if (yu[cnt - i] != 0)
        {
            for (long long j = 0; j < cnt - i; ++j)
                ans += "9*";
            ans += yu[cnt - i] + '0';
            if (flag)
                ans += "-0+";
            else
                ans += "+0-";
        }
    }
    while (ans[ans.size() - 1] == '+' || ans[ans.size() - 1] == '-')
        ans.pop_back(); // 去掉多于符号
    return ans;
}
int main()
{
    long long p = 0, q = 0;
    scanf("%lld%lld", &p, &q);
    if (abs(p) % 2 == abs(q) % 2) // 同奇偶
    {
        long long _pq = p + q >> 1, p_q = p - _pq;
        if (p == 0 && q == 0) // 特判
        {
            puts("0");
            return 0;
        }
        cout << to_9(_pq) << ((_pq != 0 && p_q != 0) ? "+" : "") << to_9_0(p_q) << endl;
    }
    else // 异奇偶
    {
        long long _pq = (p - 21 + q - 12) >> 1, p_q = p - 21 - _pq; // 转换为同奇偶
        cout << to_9(_pq) << ((_pq != 0 && p_q != 0) ? "+" : "") << to_9_0(p_q) << ((p_q != 0 || _pq != 0) ? "+" : "") << "21" << endl;
    }
    return 0;
}

```

### [CF739A Alyona and mex](https://www.luogu.com.cn/problem/CF739A)

#### CF739A题意

给定 $m$ 个区间，构造出一个长度为 $n$ 的序列，使得这 $m$ 个区间的最小 $mex$ 最大。 $mex$ 定义为最小的没有出现过的自然数。

#### CF739A题解

观察样例发现两次输出的 $mex$ 均等于最短的区间长度，显然这不是巧合。

首先很容易得出 $mex(S) \le \lvert S \rvert$，且当 $S$ 是 $0$ 到 $\lvert S \rvert - 1$ 时取等，所以最终答案不会超过最短的区间的长度，然后去思考如何构造出答案等于最短区间长度的情况。

求出最短的区间长度为 $x$，则只要在数组中循环填入 $0, 1, 2, ..., x - 1$，求能保证每一个长度大于等于 $x$ 的区间 $mex$ 一定都等于 $x$，因为每一个长度大于等于 $x$ 的区间都至少覆盖一次 $0, 1, 2, ..., x - 1$。（可以自己手搓几个样例试试）

#### CF739A代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n, m;
    scanf("%d%d", &n, &m);
    int minlen = INT_MAX;
    for (int i = 0; i < m; ++i)
    {
        int l, r;
        scanf("%d%d", &l, &r);
        minlen = min(minlen, r - l + 1);
    }
    printf("%d\n", minlen);
    int cnt = 0;
    for (int i = 1; i <= n; ++i)
        printf("%d ", i % minlen);
    return 0;
}
```

### [CF1495C Garden of the Sun](https://www.luogu.com.cn/problem/CF1495C)

#### CF1495C题意

给定一个 $n \times m$ 的矩阵，由 `X` 和 `.` 组成，保证给出的矩阵的所有 `X` 之间没有公共点或公共边。

请把一些 `.` 换成 `X`，使得所有 `X` 四连通且不存在简单环

如果有多个解，输出任意即可

$n, m \le 500, \sum n \times m \le 250000$

#### CF1495C题解

考虑将整个矩阵分割成三行三行的形式，因为题目保证没有公共边，所以就可以先把中间行填满 `X`，然后再逐个考虑每个三行之间的连接。

举例：

```txt
.X...
....X
.X...
.....
X.X.X
```

```txt
.X...
XXXXX 中间行填满
.X...
-----分割
.....
XXXXX 中间行填满
```

```txt
.X...
XXXXX
.X...
.X... 连接
XXXXX
```

#### CF1495C代码

```cpp
```

By the way，这题评测是真的慢

---
