# 倍增

- [倍增](#倍增)
  - [RMQ与ST表](#rmq与st表)
    - [应用](#应用)
      - [区间最大值](#区间最大值)
    - [ST表的优劣](#st表的优劣)
  - [例题](#例题)
    - [P2048 NOI2010 超级钢琴](#p2048-noi2010-超级钢琴)
      - [P2048题意](#p2048题意)
      - [P2048暴力代码](#p2048暴力代码)
      - [P2048题解](#p2048题解)
    - [例题2](#例题2)
      - [例题2题意](#例题2题意)
      - [例题2题解](#例题2题解)
    - [P1084 疫情控制](#p1084-疫情控制)
      - [P1084题意](#p1084题意)
      - [P1084题解](#p1084题解)
    - [P3295 萌萌哒](#p3295-萌萌哒)
      - [P3295题意](#p3295题意)
      - [P3295题解](#p3295题解)
        - [P3295朴素做法](#p3295朴素做法)
      - [P3295正解](#p3295正解)

## RMQ与ST表

RMQ 是Range Maximum/Minimum Query的缩写，表示区间最大（最小）值。

而ST表适用于解决**可重复贡献问题**的数据结构。

何为**可重复贡献问题**？记 $f(l, r)$ 表示 $[l, r]$ 这个区间的答案，可重复贡献问题就是，对于所有 $R \ge L$，$f(l, r)$ 可以被记为 $f(l, R)$ 与 $f(L, r)$ 的和合并。也就是说，可以把大区间的答案拆分为**可重合的**小区间的答案合并。

Obviously，区间max,区间and,区间gcd都是可重复贡献问题，可以用ST表维护优化。但是区间加、区间积就不是，因为不可以加上或者乘上一个已经加过的数。

### 应用

#### 区间最大值

给定 $n$ 个数，有 $m$ 次询问，对于每次询问，需要输出 $[l, r]$ 中的最大值。

令 $f(i, j)$ 表示区间 $[i, i + 2 ^ i - 1]$ 中的最大值。显然 $f(i, 0) = a_i$

很容易写出转移： $f(i, j) = max(f(i, j - 1), f(i + 2 ^ j - 1, j - 1))$

对于每个询问 $[l, r]$，我们把它分成两部分 $f(l, l + 2 ^ s - 1)$ 和 $f(r - 2 ^ s + 1, r)$，其中 $s = \lfloor log_2(r - l + 1) \rfloor$，两部分的最大值即为答案。

注意： $log$ 要预处理， $log_2 i = log_2 \frac{i}{2} + 1$。

### ST表的优劣

ST表能够较好的维护可重复贡献区间问题，时间复杂度较低，但是维护的信息有限，不支持扩展，修改。

## 例题

### [P2048 NOI2010 超级钢琴](https://www.luogu.com.cn/problem/P2048)

#### P2048题意

给定一个长度为 $n$ 的序列，要求选 $k$ 段长度在 $L$ 到 $R$ 之间的区间，使得 $k$ 个区间的区间和最大（规定区间的值为区间和）。区间可以相交或包含，但是一个区间只能选一次。

#### P2048暴力代码

```cpp
// 预期得分20
#include <bits/stdc++.h>
using namespace std;
const int maxn = 5 * 1e5 + 10;
int n, k, L, R, ans;
int sum[maxn];
priority_queue<int> q;
int main()
{
    scanf("%d%d%d%d", &n, &k, &L, &R);
    for (int i = 1; i <= n; i++)
        scanf("%d", &sum[i]), sum[i] += sum[i - 1];
    for (int i = 1; i <= n; i++)
        for (int j = i; j <= n; j++)
            if (j - i + 1 >= L && j - i + 1 <= R)
                q.push(sum[j] - sum[i - 1]);
    for (int i = 1; i <= k; i++)
        ans += q.top(), q.pop();
    printf("%d", ans);
    return 0;
}
```

#### P2048题解

首先，考虑将区间和转换为前缀和之差。

对于一个固定的 $l$，用ST表可以查询 $r \in [R_1, R_2]$ 的前缀和最大的 $r$，此时 $[l, r]$ 即为该条件下最大的。

然后将每个左端点的最优解放入优先队列，每次取出优先队列中的最优解，然后再去查询 $[l, r]$ 区间中去除最优解的最优解放入优先队列，取 $k$ 次即可

### 例题2

#### 例题2题意

有一张 $n$ 个点， $m$ 条边的有向图，边权为 $1$。从起点出发，每次能走恰好 $2^k$ 的旅程， $k$ 为自然数。求问最少多少次才能达到终点。

$n \le 50, m \le 2500$

#### 例题2题解

令 $g(u, v, j)$ 表示从点 $u$ 到点 $v$ 是否存在长度为 $2 ^ j$ 的路径， $G(u, v)$ 表示 $u, v$ 能否一步到达。

转移如下：

$g(u, w, j) = g(u, v, j - 1) \&\& g(v, w, j - 1), G(u, v)=g(u, v, 0)||g(u, v, 1)||...||g(u, v, n - 1)$

因为可能有环，所以 $j$ 需要枚举到 $n - 1$ 才能结束。

这样子相当于是重建了一张新图，因此在新图上BFS求最短路即可。

### [P1084 疫情控制](https://www.luogu.com.cn/problem/P1084)

#### P1084题意

H国有 $n$ 个城市，这 $n$ 个城市用 $n - 1$ 条双向道路连接构成一棵树。 $1$ 号城市是首都，也是树中的根节点。

根节点爆发了传染病，需要在一些节点建立检查点（根节点除外），使得根节点到每一个叶节点的路径上都有检查点。

一些节点中驻扎有军队，一个城市可以有多个军队。每一支军队可以在城市间移动，且不同军队可以同时移动，并在根节点外的任意一个节点建立检查点。一支军队移动的时间等于路径长度。

#### P1084题解

性质：在根的**同一棵**（指在不考虑走进根的其他子树的情况下）子树内的军队，越靠近根节点越优。

考虑二分答案，让所有军队的行动时间不超过 $mid$。

预处理每一个节点的祖先的倍增数组，然后利用倍增快速上移军队，如果能达到根节点并且还有剩余时间，则去考虑其他子树，该方法保留备用。

DFS查询所有叶子节点，得到分界点哪些子树需要军队驻扎，最后贪心完成匹配

复杂度 $O(n log n log t)$

### [P3295 萌萌哒](https://www.luogu.com.cn/problem/P3295)

#### P3295题意

有一个 $n$ 位的十进制数 $a$（保证无前导0），给出 $m$ 条限制，每条限制的格式如 $(l_1, r_1, l_2, r_2)$ （保证 $r_1 - l_1 = r_2 - l_2$），表示这个数的第 $[l_1, r_1]$ 位与第 $[l_2, r_2]$ 位对应相同。问有多少个这样的数满足条件。输出答案 $mod\ 10 ^ 9 + 7。

$1 \le n, m \le 10 ^ 5$

#### P3295题解

##### P3295朴素做法

考虑用并查集维护，将对应位置上的点依次合并。

设最后有 $cnt$ 个连通块，答案即为 $9 \times 10 ^ {cnt - 1}$

复杂度为 $O(nm \alpha(n))$，无法通过。

#### P3295正解

考虑用ST表的方式优化合并。

具体来说，开 $log_2 n$ 个并查集，第 $k$ 个表示对于并查集内任意两点 $u, v$，$u = v, u + 1 = v + 1, ..., u + 2 ^ k - 1 = v + 2 ^ k - 1$

对于每次给定的合并操作，我们进行多次 $2 ^ k$ 的合并。

复杂度 $O((n + q) log n \alpha(n))$

---
