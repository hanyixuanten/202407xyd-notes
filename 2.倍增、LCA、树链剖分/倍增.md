# 倍增

- [倍增](#倍增)
  - [RMQ与ST表](#rmq与st表)
    - [应用](#应用)
      - [区间最大值](#区间最大值)
    - [ST表的优劣](#st表的优劣)
  - [例题](#例题)
    - [P2048 NOI2010 超级钢琴](#p2048-noi2010-超级钢琴)
      - [P2048题意](#p2048题意)
      - [P2048暴力代码](#p2048暴力代码)
      - [P2048题解](#p2048题解)
    - [例题2](#例题2)
      - [例题2题意](#例题2题意)
      - [例题2题解](#例题2题解)

## RMQ与ST表

RMQ 是Range Maximum/Minimum Query的缩写，表示区间最大（最小）值。

而ST表适用于解决**可重复贡献问题**的数据结构。

何为**可重复贡献问题**？记 $f(l, r)$ 表示 $[l, r]$ 这个区间的答案，可重复贡献问题就是，对于所有 $R \ge L$，$f(l, r)$ 可以被记为 $f(l, R)$ 与 $f(L, r)$ 的和合并。也就是说，可以把大区间的答案拆分为**可重合的**小区间的答案合并。

Obviously，区间max,区间and,区间gcd都是可重复贡献问题，可以用ST表维护优化。但是区间加、区间积就不是，因为不可以加上或者乘上一个已经加过的数。

### 应用

#### 区间最大值

给定 $n$ 个数，有 $m$ 次询问，对于每次询问，需要输出 $[l, r]$ 中的最大值。

令 $f(i, j)$ 表示区间 $[i, i + 2 ^ i - 1]$ 中的最大值。显然 $f(i, 0) = a_i$

很容易写出转移： $f(i, j) = max(f(i, j - 1), f(i + 2 ^ j - 1, j - 1))$

对于每个询问 $[l, r]$，我们把它分成两部分 $f(l, l + 2 ^ s - 1)$ 和 $f(r - 2 ^ s + 1, r)$，其中 $s = \lfloor log_2(r - l + 1) \rfloor$，两部分的最大值即为答案。

注意： $log$ 要预处理， $log_2 i = log_2 \frac{i}{2} + 1$。

### ST表的优劣

ST表能够较好的维护可重复贡献区间问题，时间复杂度较低，但是维护的信息有限，不支持扩展，修改。

## 例题

### P2048 NOI2010 超级钢琴

#### P2048题意

给定一个长度为 $n$ 的序列，要求选 $k$ 段长度在 $L$ 到 $R$ 之间的区间，使得 $k$ 个区间的区间和最大（规定区间的值为区间和）。区间可以相交或包含，但是一个区间只能选一次。

#### P2048暴力代码

```cpp
// 预期得分20
#include <bits/stdc++.h>
using namespace std;
const int maxn = 5 * 1e5 + 10;
int n, k, L, R, ans;
int sum[maxn];
priority_queue<int> q;
int main()
{
    scanf("%d%d%d%d", &n, &k, &L, &R);
    for (int i = 1; i <= n; i++)
        scanf("%d", &sum[i]), sum[i] += sum[i - 1];
    for (int i = 1; i <= n; i++)
        for (int j = i; j <= n; j++)
            if (j - i + 1 >= L && j - i + 1 <= R)
                q.push(sum[j] - sum[i - 1]);
    for (int i = 1; i <= k; i++)
        ans += q.top(), q.pop();
    printf("%d", ans);
    return 0;
}
```

#### P2048题解

首先，考虑将区间和转换为前缀和之差。

对于一个固定的 $l$，用ST表可以查询 $r \in [R_1, R_2]$ 的前缀和最大的 $r$，此时 $[l, r]$ 即为该条件下最大的。

然后将每个左端点的最优解放入优先队列，每次取出优先队列中的最优解，然后再去查询 $[l, r]$ 区间中去除最优解的最优解放入优先队列，取 $k$ 次即可

### 例题2

#### 例题2题意

有一张 $n$ 个点， $m$ 条边的有向图，边权为 $1$。从起点出发，每次能走恰好 $2^k$ 的旅程， $k$ 为自然数。求问最少多少次才能达到终点。

$n \le 50, m \le 2500$

#### 例题2题解

令 $g(u, v, j)$ 表示从点 $u$ 到点 $v$ 是否存在长度为 $2 ^ j$ 的路径， $G(u, v)$ 表示 $u, v$ 能否一步到达。

转移如下：

$g(u, w, j) = g(u, v, j - 1) \&\& g(v, w, j - 1), G(u, v)=g(u, v, 0)||g(u, v, 1)||...||g(u, v, n - 1)$

因为可能有环，所以 $j$ 需要枚举到 $n - 1$ 才能结束。

这样子相当于是重建了一张新图，因此在新图上BFS求最短路即可。

---
