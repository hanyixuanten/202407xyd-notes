# 树链剖分

- [树链剖分](#树链剖分)
  - [概念](#概念)
  - [基本定义](#基本定义)
  - [约定定义](#约定定义)
  - [基本性质](#基本性质)
  - [例题](#例题)
    - [例题0](#例题0)
      - [例题0题意](#例题0题意)
      - [例题0题解](#例题0题解)
    - [P1967 货车运输](#p1967-货车运输)
      - [P1967题意](#p1967题意)
      - [P1967题解](#p1967题解)
      - [P1967示例代码](#p1967示例代码)
    - [P1084 疫情控制](#p1084-疫情控制)
      - [P1084题意](#p1084题意)
      - [P1084题解](#p1084题解)

## 概念

树链剖分用于把一棵树分割成若干条链的形式，以维护树上路径信息。

树链剖分有多种形式，如**重链剖分**，**长链剖分**和用于Link/Cut Tree的剖分（有时又称实链剖分）。在没有特殊说明的情况下，树链剖分都指的是***重链剖分***

重链剖分可以将树上任意路径划分成 $\le O(log n)$ 条链，每条链上点的深度互不相同（即自底向上的一条链，所有点的LCA为链的一个端点）

## 基本定义

- **重子节点**表示其子节点中对打的子节点。如果有多个最大的，则任取其一。
- **轻子节点**表示除去重子节点外其他所有子节点。
- 从这个节点到重子节点的边叫做**重边**
- 到其余子节点的边叫做**轻边**
- 若干条首尾相接的重边称作**重链**
- 把最后不在重链中的节点也当作一个重链，那么整棵树便被分割为若干条重链。

整个过程可以用两次DFS完成，一边找重链，一边找落单节点

举例：

![举例](image.png)

## 约定定义

- $fa(x)$ 表示 $x$ 在树上的父亲
- $dep(x)$ 表示 $x$ 在树上的深度
- $siz(x)$ 表示 $x$ 子树节点数量
- $son(x)$ 表示 $x$ 的重儿子
- $top(x)$ 表示 $x$ 所在重链的顶部（深度最小）的节点
- $dfn(x)$ 表示 $x$ 的DFS序，也是在线段树中的编号
- $rnk(x)$ 表示 DFS序所对应的节点编号，显然 $rnk(dfn(x)) = x$

在进行两次dfs时，同时也处理这些值，第一次求出 $fa, dep, siz$，第二次求出 $top, dfn, rnk$

## 基本性质

- 树上每个节点仅属于一条重链
- 重链的开头一定是轻子节点
- 在剖分的时候，因为优先遍历重边，所以树的DFS序上，重链内部的DFS序是里连续的。

## 例题

### 例题0

#### 例题0题意

给定一棵 $n$ 个点的带权树， $q$ 次询问 $u$ 到 $v$ 的最短距离。

#### 例题0题解

公式： $distance(u, v) = dep(u) + dep(u) - 2dep(LCA(u, v))$

### P1967 货车运输

#### P1967题意

A国有 $n$ 座城市，编号从 $1$ 到 $n$，城市之间有 $m$ 条双向道路，每一条路都有限重。

现有 $q$ 辆货车运送货物，第 $i$ 辆货车起点为 $s_i$，终点为 $t_i$。司机们想知道在不超过限重的情况下，可以运多重的货物。

$n, m, q \le 10^5$

#### P1967题解

求出最大生成树，问题就转换为了树上链的最小值。

主要有以下两种解法：

- 倍增。预处理 $w(u, k)$ 表示从 $u$ 往上跳 $k$ 步，经过的边权最小值。在算LCA时顺便计算最小值即可。
- 树剖+ST表。树剖后路径变成 $O(log n)$ 条重链，也就是 $O(log n)$ 次询问区间min,用ST表求即可。

两种方法时间复杂度均为 $O(n log n)$

#### P1967示例代码

```cpp
#include <bits/stdc++.h>
const int MAXN = 100010;
using namespace std;
bool f;
int n, m, q;
struct node
{
    int st, ed, v;
} Edge[MAXN];
int pre[MAXN];
bool cmp(node A, node B) { return A.v > B.v; }
int fFind(int x)
{
    if (pre[x] == x)
        return x;
    return pre[x] = fFind(pre[x]);
}
struct nd
{
    vector<node> G[MAXN];
    int F[MAXN][20], num[MAXN][20], lg[MAXN], deep[MAXN], root[MAXN];
    bool mark[MAXN], vis[MAXN];
    void dfs(int x, int fa, int val, int rt)
    {
        root[x] = rt;
        F[x][0] = fa;
        num[x][0] = val;
        deep[x] = deep[fa] + 1;
        for (int i = 1; (1 << i) <= deep[x]; i++)
            F[x][i] = F[F[x][i - 1]][i - 1], num[x][i] = min(num[x][i - 1], num[F[x][i - 1]][i - 1]);
        for (int i = 0; i < G[x].size(); i++)
        {
            int t = G[x][i].ed, val = G[x][i].v;
            if (t == fa)
                continue;
            dfs(t, x, val, rt);
        }
    }
    int LCA(int x, int y)
    {
        if (deep[x] < deep[y])
            swap(x, y);
        int res = 2e9 + 7;
        while (deep[x] > deep[y])
            res = min(res, num[x][lg[deep[x] - deep[y]] - 1]), x = F[x][lg[deep[x] - deep[y]] - 1];
        if (x == y)
            return res;
        for (int i = lg[deep[x]] - 1; i >= 0; i--)
        {
            if (F[x][i] == F[y][i])
                continue;
            res = min(res, num[x][i]);
            res = min(res, num[y][i]);
            x = F[x][i], y = F[y][i];
        }
        res = min(res, num[x][0]);
        res = min(res, num[y][0]);
        return res;
    }
    void work()
    {
        for (int i = 1; i <= MAXN - 10; i++)
            lg[i] = lg[i - 1] + ((1 << lg[i - 1]) == i);
        for (int i = 1; i <= n; i++)
            pre[i] = i;
        for (int i = 1; i <= m; i++)
        {
            int x, y, z;
            scanf("%d %d %d", &x, &y, &z);
            Edge[i] = node{x, y, z};
        }
        sort(Edge + 1, Edge + 1 + m, cmp);
        for (int i = 1; i <= m; i++)
        {
            int fx = fFind(Edge[i].st), fy = fFind(Edge[i].ed);
            if (fx == fy)
                continue;
            mark[Edge[i].st] = mark[Edge[i].ed] = true;
            pre[fx] = fy;
            G[Edge[i].st].push_back(node{0, Edge[i].ed, Edge[i].v});
            G[Edge[i].ed].push_back(node{0, Edge[i].st, Edge[i].v});
        }
        for (int i = 1; i <= n; i++)
            if (!root[i])
                dfs(i, 0, 0, i);
        scanf("%d", &q);
        for (int i = 1; i <= q; i++)
        {
            int x, y;
            scanf("%d %d", &x, &y);
            if (root[x] != root[y])
            {
                puts("-1");
                continue;
            }
            printf("%d\n", LCA(x, y));
        }
    }
} r;
bool fflag;
int main()
{
    scanf("%d %d", &n, &m);
    r.work();
    return 0;
}
```

### P1084 疫情控制

#### P1084题意

H国有 $n$ 个城市，这 $n$ 个城市用 $n - 1$ 条双向道路连接构成一棵树。 $1$ 号城市是首都，也是树中的根节点。

根节点爆发了传染病，需要在一些节点建立检查点（根节点除外），使得根节点到每一个叶节点的路径上都有检查点。

一些节点中驻扎有军队，一个城市可以有多个军队。每一支军队可以在城市间移动，且不同军队可以同时移动，并在根节点外的任意一个节点建立检查点。一支军队移动的时间等于路径长度。

#### P1084题解

性质：在根的一棵子树内的军队，越靠近根节点越优（在不考虑走进根的其他子树的情况下）。

考虑二分答案，让所有军队的行动时间不超过 $mid$。

预处理每一个节点的祖先的倍增数组，然后利用倍增快速上移军队，如果能达到根节点并且还有剩余时间，则去考虑其他子树，该方法保留备用。

DFS查询所有叶子节点，得到分界点哪些子树需要军队驻扎，最后贪心完成匹配

---
